{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Problem Details for PSR-7 Applications Repository abandoned 2019-12-31 This repository has moved to mezzio/mezzio-problem-details . This library provides a factory for generating Problem Details responses, error handling middleware for automatically generating Problem Details responses from errors and exceptions, and custom exception types for PSR-7 applications. Installation Run the following to install this library: $ composer require zendframework/zend-problem-details Documentation Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"Home"},{"location":"#problem-details-for-psr-7-applications","text":"","title":"Problem Details for PSR-7 Applications"},{"location":"#repository-abandoned-2019-12-31","text":"This repository has moved to mezzio/mezzio-problem-details . This library provides a factory for generating Problem Details responses, error handling middleware for automatically generating Problem Details responses from errors and exceptions, and custom exception types for PSR-7 applications.","title":"Repository abandoned 2019-12-31"},{"location":"#installation","text":"Run the following to install this library: $ composer require zendframework/zend-problem-details","title":"Installation"},{"location":"#documentation","text":"Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"Documentation"},{"location":"default-types/","text":"Default Types Since 1.1.0. When you raise your own exceptions implementing Zend\\ProblemDetails\\Exception\\ProblemDetailsExceptionInterface you will always be in control of all the properties returned as part of the response payload, including the status , type , title , detail , etc. items. However, there are some use cases in which this library will have to infer some of those values. The main situations in which this can happen are: When an exception not implementing ProblemDetailsExceptionInterface is captured by the ProblemDetailsMiddleware . When the ProblemDetailsNotFoundHandler is executed. In these two cases, the title and type properties will be inferred from the status code, which will usually be 500 in the first case and 404 in the second one. To be more precise, the ProblemDetailsMiddleware will use the exception's error code when debug is true , and 500 otherwise. Because of this, in any of those cases, you will end up with values like https://httpstatus.es/404 or https://httpstatus.es/500 for the type property. Configuring custom default types Since the type property will usually be used by API consumers to uniquely identify an error, you might want to be able to provide your own custom values for the type property. In order to do that, this library lets you configure the default type value to be used for every status code when some of the cases listed above happens. return [ 'problem-details' => [ 'default_types_map' => [ 404 => 'https://example.com/problem-details/error/not-found', 500 => 'https://example.com/problem-details/error/internal-server-error', ], ], ]; If this configuration is found, it will be consumed by the ProblemDetailsResponseFactoryFactory and your custom values will be used when the type was not explicitly provided.","title":"Default Types"},{"location":"default-types/#default-types","text":"Since 1.1.0. When you raise your own exceptions implementing Zend\\ProblemDetails\\Exception\\ProblemDetailsExceptionInterface you will always be in control of all the properties returned as part of the response payload, including the status , type , title , detail , etc. items. However, there are some use cases in which this library will have to infer some of those values. The main situations in which this can happen are: When an exception not implementing ProblemDetailsExceptionInterface is captured by the ProblemDetailsMiddleware . When the ProblemDetailsNotFoundHandler is executed. In these two cases, the title and type properties will be inferred from the status code, which will usually be 500 in the first case and 404 in the second one. To be more precise, the ProblemDetailsMiddleware will use the exception's error code when debug is true , and 500 otherwise. Because of this, in any of those cases, you will end up with values like https://httpstatus.es/404 or https://httpstatus.es/500 for the type property.","title":"Default Types"},{"location":"default-types/#configuring-custom-default-types","text":"Since the type property will usually be used by API consumers to uniquely identify an error, you might want to be able to provide your own custom values for the type property. In order to do that, this library lets you configure the default type value to be used for every status code when some of the cases listed above happens. return [ 'problem-details' => [ 'default_types_map' => [ 404 => 'https://example.com/problem-details/error/not-found', 500 => 'https://example.com/problem-details/error/internal-server-error', ], ], ]; If this configuration is found, it will be consumed by the ProblemDetailsResponseFactoryFactory and your custom values will be used when the type was not explicitly provided.","title":"Configuring custom default types"},{"location":"exception/","text":"Problem Details Exceptions If you are developing an API, it may be useful to raise exceptions from your business domain that contain all the information necessary to report problem details. To facilitate this, we provide an interface, ProblemDetailsExceptionInterface : namespace Zend\\ProblemDetails\\Exception; use JsonSerializable; interface ProblemDetailsExceptionInterface extends JsonSerializable { public function getStatus() : int; public function getType() : string; public function getTitle() : string; public function getDetail() : string; public function getAdditionalData() : array; public function toArray() : array; } You may create exceptions that implement this interface. When such exceptions are passed to ProblemDetailsResponseFactory::createResponseFromThrowable() , these will pull the relevant details in order to create a Problem Details response. To facilitate creating such exception types, we also ship the trait CommonProblemDetailsExceptionTrait . This trait defines the following properties: $status $detail $title $type $additional and implements each of the methods of the interface. This allows you as a developer to create implementations with either constructors or named constructors for generating exception instances. As an example, if you wanted to create an exception type for providing transaction problem details, you might do so as follows: use DomainException; use Zend\\ProblemDetails\\Exception\\CommonProblemDetailsExceptionTrait; use Zend\\ProblemDetails\\Exception\\ProblemDetailsExceptionInterface; class TransactionException extends DomainException implements ProblemDetailsExceptionInterface { use CommonProblemDetailsExceptionTrait; const STATUS = 403; const TYPE = 'https://example.com/problems/insufficient-funds'; const TITLE = 'You have insufficient funds to complete the transaction.'; public static function create(int $needed, float $balance, string $account) : self { $e = new self(sprintf( 'Your transaction required %01.2f, but you only have %01.2f in your account', $needed, $balance )); $e->status = self::STATUS; $e->type = self::TYPE; $e->title = self::TITLE; $e->additional = [ 'account' => $account, 'balance' => $balance, ]; return $e; } } You might then raise the exception as follows: throw TransactionException::create($price, $balance, $accountUri); And it might result in the following: { \"status\": 403, \"type\": \"https://example.com/problems/insufficient-funds\", \"title\": \"You have insufficient funds to complete the transaction.\", \"detail\": \"Your transaction required 5.63, but you only have 1.37 in your account\", \"account\": \"https://example.com/api/accounts/12345\", \"balance\": 1.37 } The benefit to this approach is that you can easily provide domain-specific exceptions throughout your application that can, as a side-effect, be re-purposed immediately to provide problem details in your application.","title":"Exceptions"},{"location":"exception/#problem-details-exceptions","text":"If you are developing an API, it may be useful to raise exceptions from your business domain that contain all the information necessary to report problem details. To facilitate this, we provide an interface, ProblemDetailsExceptionInterface : namespace Zend\\ProblemDetails\\Exception; use JsonSerializable; interface ProblemDetailsExceptionInterface extends JsonSerializable { public function getStatus() : int; public function getType() : string; public function getTitle() : string; public function getDetail() : string; public function getAdditionalData() : array; public function toArray() : array; } You may create exceptions that implement this interface. When such exceptions are passed to ProblemDetailsResponseFactory::createResponseFromThrowable() , these will pull the relevant details in order to create a Problem Details response. To facilitate creating such exception types, we also ship the trait CommonProblemDetailsExceptionTrait . This trait defines the following properties: $status $detail $title $type $additional and implements each of the methods of the interface. This allows you as a developer to create implementations with either constructors or named constructors for generating exception instances. As an example, if you wanted to create an exception type for providing transaction problem details, you might do so as follows: use DomainException; use Zend\\ProblemDetails\\Exception\\CommonProblemDetailsExceptionTrait; use Zend\\ProblemDetails\\Exception\\ProblemDetailsExceptionInterface; class TransactionException extends DomainException implements ProblemDetailsExceptionInterface { use CommonProblemDetailsExceptionTrait; const STATUS = 403; const TYPE = 'https://example.com/problems/insufficient-funds'; const TITLE = 'You have insufficient funds to complete the transaction.'; public static function create(int $needed, float $balance, string $account) : self { $e = new self(sprintf( 'Your transaction required %01.2f, but you only have %01.2f in your account', $needed, $balance )); $e->status = self::STATUS; $e->type = self::TYPE; $e->title = self::TITLE; $e->additional = [ 'account' => $account, 'balance' => $balance, ]; return $e; } } You might then raise the exception as follows: throw TransactionException::create($price, $balance, $accountUri); And it might result in the following: { \"status\": 403, \"type\": \"https://example.com/problems/insufficient-funds\", \"title\": \"You have insufficient funds to complete the transaction.\", \"detail\": \"Your transaction required 5.63, but you only have 1.37 in your account\", \"account\": \"https://example.com/api/accounts/12345\", \"balance\": 1.37 } The benefit to this approach is that you can easily provide domain-specific exceptions throughout your application that can, as a side-effect, be re-purposed immediately to provide problem details in your application.","title":"Problem Details Exceptions"},{"location":"intro/","text":"Problem Details This library addresses RFC 7807: Problem Details for HTTP APIs for usage with PSR-7 HTTP Messages and PSR-15 HTTP Handlers . Problem Details for HTTP APIs When developing APIs, it is good practice to: Use HTTP status codes to help convey error status. Provide sufficient error detail to clients. Unfortunately, unless you are using a documented RPC format such as XML-RPC, JSON-RPC, or SOAP, how to return error details is not dictated, and many API developers end up creating their own formats. Most standardized RPC formats do not use the HTTP status code to convey an error, only the payload, and, in fact, most clients of such services will fail if a non-200 status is returned. RFC 7807 provides a standard format for returning problem details from HTTP APIs. In particular, it specifies the following: Error responses MUST use standard HTTP status codes in the 400 or 500 range to detail the general category of error. Error responses will be of the Content-Type application/problem , appending a serialization format of either json or xml : application/problem+json , application/problem+xml . Error responses will have each of the following keys: detail , a human-readable description of the specific error. type , a unique URI for the general error type, generally pointing to human-readable documentation of that given type. title , a short, human-readable title for the general error type; the title should not change for given type s. status , conveying the HTTP status code; this is so that all information is in one place, but also to correct for changes in the status code due to usage of proxy servers. Optionally, an instance key may be present, with a unique URI for the specific error; this will often point to an error log for that specific response. Finally, problem details are extensible . You may provide additional keys that give the consumer more information about the error. As an example, in an API that has rate limiting, you may want to indicate how many requests the user has made, what the rate limit is, and when the limit resets: { \"type\": \"https://example.com/problems/rate-limit-exceeded\", \"title\": \"You have exceeded your API rate limit.\", \"detail\": \"You have hit your rate limit of 5000 requests per hour.\", \"requests_this_hour\": 5025, \"rate_limit\": 5000, \"rate_limit_reset\": \"2017-05-03T14:39-0500\" } Custom errors What if you have custom error types? RFC 7807 specifically allows you to define these with the following: A URI to documentation of the error type . A human-readable title describing the error type. One or more HTTP status codes associated with the error type. For your custom errors, you use the above with a problem details response; if the problem type requires additional information, you provide it within the payload, and document that information at the URI describing the type. This approach allows usage of a single, general-purpose media type for returning problem details for your HTTP API, while allowing full customization of what types of errors you report. ProblemDetails This library provides custom PSR-7 responses for JSON and XML representations of application/problem . Additionally, it provides a factory that will introspect the contents of a provided Accept header in order to determine which representation to return, defaulting to the XML representation. This factory may then be composed in middleware in order to create and return problem details responses. Additionally, the library provides middleware that acts as an error and exception handler and wrapping calls to a request handler, converting each into problem details responses.","title":"Introduction"},{"location":"intro/#problem-details","text":"This library addresses RFC 7807: Problem Details for HTTP APIs for usage with PSR-7 HTTP Messages and PSR-15 HTTP Handlers .","title":"Problem Details"},{"location":"intro/#problem-details-for-http-apis","text":"When developing APIs, it is good practice to: Use HTTP status codes to help convey error status. Provide sufficient error detail to clients. Unfortunately, unless you are using a documented RPC format such as XML-RPC, JSON-RPC, or SOAP, how to return error details is not dictated, and many API developers end up creating their own formats. Most standardized RPC formats do not use the HTTP status code to convey an error, only the payload, and, in fact, most clients of such services will fail if a non-200 status is returned. RFC 7807 provides a standard format for returning problem details from HTTP APIs. In particular, it specifies the following: Error responses MUST use standard HTTP status codes in the 400 or 500 range to detail the general category of error. Error responses will be of the Content-Type application/problem , appending a serialization format of either json or xml : application/problem+json , application/problem+xml . Error responses will have each of the following keys: detail , a human-readable description of the specific error. type , a unique URI for the general error type, generally pointing to human-readable documentation of that given type. title , a short, human-readable title for the general error type; the title should not change for given type s. status , conveying the HTTP status code; this is so that all information is in one place, but also to correct for changes in the status code due to usage of proxy servers. Optionally, an instance key may be present, with a unique URI for the specific error; this will often point to an error log for that specific response. Finally, problem details are extensible . You may provide additional keys that give the consumer more information about the error. As an example, in an API that has rate limiting, you may want to indicate how many requests the user has made, what the rate limit is, and when the limit resets: { \"type\": \"https://example.com/problems/rate-limit-exceeded\", \"title\": \"You have exceeded your API rate limit.\", \"detail\": \"You have hit your rate limit of 5000 requests per hour.\", \"requests_this_hour\": 5025, \"rate_limit\": 5000, \"rate_limit_reset\": \"2017-05-03T14:39-0500\" }","title":"Problem Details for HTTP APIs"},{"location":"intro/#custom-errors","text":"What if you have custom error types? RFC 7807 specifically allows you to define these with the following: A URI to documentation of the error type . A human-readable title describing the error type. One or more HTTP status codes associated with the error type. For your custom errors, you use the above with a problem details response; if the problem type requires additional information, you provide it within the payload, and document that information at the URI describing the type. This approach allows usage of a single, general-purpose media type for returning problem details for your HTTP API, while allowing full customization of what types of errors you report.","title":"Custom errors"},{"location":"intro/#problemdetails","text":"This library provides custom PSR-7 responses for JSON and XML representations of application/problem . Additionally, it provides a factory that will introspect the contents of a provided Accept header in order to determine which representation to return, defaulting to the XML representation. This factory may then be composed in middleware in order to create and return problem details responses. Additionally, the library provides middleware that acts as an error and exception handler and wrapping calls to a request handler, converting each into problem details responses.","title":"ProblemDetails"},{"location":"middleware/","text":"Problem Details Middleware While returning a problem details response from your own middleware is powerful and flexible, sometimes you may want a fail-safe way to return problem details for any exception or PHP error that occurs without needing to catch and handle them yourself. For this purpose, this library provides ProblemDetailsMiddleware . This middleware does the following: Composes a ProblemDetailsResponseFactory . Determines if the request accepts JSON or XML; if neither is accepted, it simply passes execution to the request handler. Registers a PHP error handler using the current error_reporting mask, and throwing any errors handled as ErrorException instances. Wraps a call to the $handler in a try / catch block; if nothing is caught, it returns the response immediately. For all caught throwables, it passes the throwable to ProblemDetailsResponseFactory::createResponseFromThrowable() to generate a Problem Details response. As such, you can register this in middleware stacks in order to automate generation of problem details for exceptions and PHP errors. As an example, using Expressive, you could compose it as an error handler within your application pipeline, having it handle all errors and exceptions from your application: $app->pipe(ProblemDetailsMiddleware::class); Or for a subpath of your application: $app->pipe('/api', ProblemDetailsMiddleware::class); Alternately, you could pipe it within a routed-middleware pipeline: $app->get('/api/books', [ ProblemDetailsMiddleware::class, BooksList::class, ], 'books'); This latter approach ensures that you are only providing problem details for specific API endpoints, which can be useful when you have a mix of APIs and traditional web content in your application. Listeners Since 0.5.2 The ProblemDetailsMiddleware allows you to register listeners to trigger when it handles a Throwable . Listeners are PHP callables, and the middleware triggers them with the following arguments, in the following order: Throwable $error : the throwable/exception caught by the middleware. ServerRequestInterface $request : the request as provided to the ProblemDetailsMiddleware . ResponseInterface $response : the response the ProblemDetailsMiddleware generated based on the $error . Note that each of these arguments are immutable; you cannot change the state in a way that that state will propagate meaningfully. As such, you should use listeners for reporting purposes only (e.g., logging). As an example: // Where $logger is a PSR-3 logger implementation $listener = function ( Throwable $error, ServerRequestInterface $request, ResponseInterface $response ) use ($logger) { $logger->error('[{status}] {method} {uri}: {message}', [ 'status' => $response->getStatusCode(), 'method' => $request->getMethod(), 'uri' => (string) $request->getUri(), 'message' => $error->getMessage(), ]); }; Attach listeners to the ProblemDetailsMiddleware instance using its attachListener() method: $middleware->attachListener($listener); Factory The ProblemDetailsMiddleware ships with a corresponding PSR-11 compatible factory, ProblemDetailsMiddlewareFactory . This factory uses the service named Zend\\ProblemDetails\\ProblemDetailsResponseFactory to instantiate the middleware. For Expressive 2+ users, this middleware should be registered automatically with your application on install, assuming you have the zend-component-installer plugin in place (it's shipped by default with the Expressive skeleton). Registering listeners Since 0.5.2 In order to register listeners, we recommend using a delegator factory on the Zend\\ProblemDetails\\ProblemDetailsMiddleware service. As an example: class LoggerProblemDetailsListenerDelegator { public function __construct(ContainerInterface $container, $serviceName, callable $callback) { $middleware = $callback(); $middleware->attachListener($container->get(LoggerProblemDetailsListener::class)); return $middleware; } } You would then register this as a delegator factory in your configuration: 'delegators' => [ ProblemDetailsMiddleware::class => [ LoggerProblemDetailsListenerDelegator::class, ], ],","title":"Error Handling Middleware"},{"location":"middleware/#problem-details-middleware","text":"While returning a problem details response from your own middleware is powerful and flexible, sometimes you may want a fail-safe way to return problem details for any exception or PHP error that occurs without needing to catch and handle them yourself. For this purpose, this library provides ProblemDetailsMiddleware . This middleware does the following: Composes a ProblemDetailsResponseFactory . Determines if the request accepts JSON or XML; if neither is accepted, it simply passes execution to the request handler. Registers a PHP error handler using the current error_reporting mask, and throwing any errors handled as ErrorException instances. Wraps a call to the $handler in a try / catch block; if nothing is caught, it returns the response immediately. For all caught throwables, it passes the throwable to ProblemDetailsResponseFactory::createResponseFromThrowable() to generate a Problem Details response. As such, you can register this in middleware stacks in order to automate generation of problem details for exceptions and PHP errors. As an example, using Expressive, you could compose it as an error handler within your application pipeline, having it handle all errors and exceptions from your application: $app->pipe(ProblemDetailsMiddleware::class); Or for a subpath of your application: $app->pipe('/api', ProblemDetailsMiddleware::class); Alternately, you could pipe it within a routed-middleware pipeline: $app->get('/api/books', [ ProblemDetailsMiddleware::class, BooksList::class, ], 'books'); This latter approach ensures that you are only providing problem details for specific API endpoints, which can be useful when you have a mix of APIs and traditional web content in your application.","title":"Problem Details Middleware"},{"location":"middleware/#listeners","text":"Since 0.5.2 The ProblemDetailsMiddleware allows you to register listeners to trigger when it handles a Throwable . Listeners are PHP callables, and the middleware triggers them with the following arguments, in the following order: Throwable $error : the throwable/exception caught by the middleware. ServerRequestInterface $request : the request as provided to the ProblemDetailsMiddleware . ResponseInterface $response : the response the ProblemDetailsMiddleware generated based on the $error . Note that each of these arguments are immutable; you cannot change the state in a way that that state will propagate meaningfully. As such, you should use listeners for reporting purposes only (e.g., logging). As an example: // Where $logger is a PSR-3 logger implementation $listener = function ( Throwable $error, ServerRequestInterface $request, ResponseInterface $response ) use ($logger) { $logger->error('[{status}] {method} {uri}: {message}', [ 'status' => $response->getStatusCode(), 'method' => $request->getMethod(), 'uri' => (string) $request->getUri(), 'message' => $error->getMessage(), ]); }; Attach listeners to the ProblemDetailsMiddleware instance using its attachListener() method: $middleware->attachListener($listener);","title":"Listeners"},{"location":"middleware/#factory","text":"The ProblemDetailsMiddleware ships with a corresponding PSR-11 compatible factory, ProblemDetailsMiddlewareFactory . This factory uses the service named Zend\\ProblemDetails\\ProblemDetailsResponseFactory to instantiate the middleware. For Expressive 2+ users, this middleware should be registered automatically with your application on install, assuming you have the zend-component-installer plugin in place (it's shipped by default with the Expressive skeleton).","title":"Factory"},{"location":"not-found-handler/","text":"Not Found Handler This library provides a Not Found handler so that returned 404 responses are in the problem details format. This handler will create a problem details Response with a 404 status code and a problem details body that will be rendered in either JSON or XML as required by the request's Accept header. This handler will only return a response if the request's accept header indicates that it will accept either JSON or XML. To use this handler in Expressive add it into your pipeline (usually pipeline.php ) immediate before the default NotFoundHandler : $app->pipe(\\Zend\\ProblemDetails\\ProblemDetailsNotFoundHandler::class); $app->pipe(NotFoundHandler::class);","title":"Not Found Handler"},{"location":"not-found-handler/#not-found-handler","text":"This library provides a Not Found handler so that returned 404 responses are in the problem details format. This handler will create a problem details Response with a 404 status code and a problem details body that will be rendered in either JSON or XML as required by the request's Accept header. This handler will only return a response if the request's accept header indicates that it will accept either JSON or XML. To use this handler in Expressive add it into your pipeline (usually pipeline.php ) immediate before the default NotFoundHandler : $app->pipe(\\Zend\\ProblemDetails\\ProblemDetailsNotFoundHandler::class); $app->pipe(NotFoundHandler::class);","title":"Not Found Handler"},{"location":"quick-start/","text":"Quick Start Installation To install this package in your application, use Composer : $ composer require zendframework/zend-problem-details Usage This package provides three primary mechanisms for creating and returning Problem Details responses: ProblemDetailsResponseFactory for generating problem details responses on the fly from either PHP primitives or exceptions/throwables. ProblemDetailsExceptionInterface for creating exceptions with additional problem details that may be used when generating a response. ProblemDetailsMiddleware that acts as error/exception handler middleware, casting and throwing PHP errors as ErrorException instances, and all caught exceptions as problem details responses using the ProblemDetailsResponseFactory . ProblemDetailsResponseFactory If you are using Expressive and have installed zend-component-installer (which is installed by default in v2.0 and above), you can write middleware that composes the Zend\\ProblemDetails\\ProblemDetailsResponseFactory immediately, and inject that service in your middleware. As an example, the following catches domain exceptions and uses them to create problem details responses: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Throwable; use Zend\\Diactoros\\Response\\JsonResponse; use Zend\\ProblemDetails\\ProblemDetailsResponseFactory; class DomainTransactionMiddleware implements MiddlewareInterface { private $domainService; private $problemDetailsFactory; public function __construct( DomainService $service, ProblemDetailsResponseFactory $problemDetailsFactory ) { $this->domainService = $service; $this->problemDetailsFactory = $problemDetailsFactory; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { try { $result = $this->domainService->transaction($request->getParsedBody()); return new JsonResponse($result); } catch (DomainException $e) { return $this->problemDetailsFactory->createResponseFromThrowable($request, $e); } } } The factory for the above might look like: use Psr\\Container\\ContainerInterface; use Zend\\ProblemDetails\\ProblemDetailsResponseFactory; class DomainTransactionMiddlewareFactory { public function __invoke(ContainerInterface $container) { return new DomainTransactionMiddleware( $container->get(DomainService::class), $container->get(ProblemDetailsResponseFactory::class) ); } } Another way to use the factory is to provide PHP primitives to the factory. As an example, validation failure is an expected condition, but should likely result in problem details to the end user. use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Throwable; use Zend\\Diactoros\\Response\\JsonResponse; use Zend\\InputFilter\\InputFilterInterface; use Zend\\ProblemDetails\\ProblemDetailsResponseFactory; class DomainTransactionMiddleware implements MiddlewareInterface { private $domainService; private $inputFilter; private $problemDetailsFactory; public function __construct( DomainService $service, InputFilterInterface $inputFilter, ProblemDetailsResponseFactory $problemDetailsFactory ) { $this->domainService = $service; $this->inputFilter = $inputFilter; $this->problemDetailsFactory = $problemDetailsFactory; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $this->inputFilter->setData($request->getParsedBody()); if (! $this->inputFilter->isValid()) { return $this->problemDetailsFactory->createResponse( $request, 422, 'Domain transaction request failed validation', '', '', ['messages' => $this->inputFilter->getMessages()] ); } try { $result = $this->domainService->transaction($this->inputFilter->getValues()); return new JsonResponse($result); } catch (DomainException $e) { return $this->problemDetailsFactory->createResponseFromThrowable($request, $e); } } } The above modifies the original example to add validation and, on failed validation, return a custom response that includes the validation failure messages. Custom Exceptions In the above examples, we have a DomainException that is used to create a Problem Details response. By default, in production mode, the factory will use the exception message as the Problem Details description, and the exception code as the HTTP status if it falls in the 400 or 500 range (500 will be used otherwise). You can also create custom exceptions that provide details for the factory to consume by implementing Zend\\ProblemDetails\\Exception\\ProblemDetailsExceptionInterface , which defines the following: namespace Zend\\ProblemDetails\\Exception; use JsonSerializable; interface ProblemDetailsExceptionInterface extends JsonSerializable { public function getStatus() : int; public function getType() : string; public function getTitle() : string; public function getDetail() : string; public function getAdditionalData() : array; public function toArray() : array; } We also provide the trait CommonProblemDetailsExceptionTrait , which implements each of the above, the jsonSerialize() method, and also defines the following instance properties: /** * @var int */ private $status; /** * @var string */ private $detail; /** * @var string */ private $title; /** * @var string */ private $type; /** * @var array */ private $additional = []; By composing this trait, you can easily define custom exception types: namespace Api; use DomainException as PhpDomainException; use Zend\\ProblemDetails\\Exception\\CommonProblemDetailsExceptionTrait; use Zend\\ProblemDetails\\Exception\\ProblemDetailsExceptionInterface; class DomainException extends PhpDomainException implements ProblemDetailsExceptionInterface { use CommonProblemDetailsExceptionTrait; public static function create(string $message, array $details) : self { $e = new self($message) $e->status = 417; $e->detail = $message; $e->type = 'https://example.com/api/doc/domain-exception'; $e->title = 'Domain transaction failed'; $e->additional['transaction'] = $details; return $e; } } The data present in the generated exception will then be used by the ProblemDetailsResponseFactory to generate full Problem Details. Error handling When writing APIs, you may not want to handle every error or exception manually, or may not be aware of problems in your code that might lead to them. In such cases, having error handling middleware that can generate problem details can be handy. This package provides ProblemDetailsMiddleware for that situation. It composes a ProblemDetailsResponseFactory , and does the following: If the request can not accept either JSON or XML responses, it simply passes handling to the request handler. Otherwise, it creates a PHP error handler that converts PHP errors to ErrorException instances, and then wraps processing of the request handler in a try/catch block. Any throwable or exception caught is passed to the ProblemDetailsResponseFactory::createResponseFromThrowable() method, and the response generated is returned. When using Expressive, the middleware service is already wired to a factory that ensures the ProblemDetailsResponseFactory is composed. As such, you can wire it into your workflow in several ways. First, you can have it intercept every request: $app->pipe(ProblemDetailsMiddleware::class); With Expressive, you can also segregate this to a subpath: $app->pipe('/api', ProblemDetailsMiddleware::class); Finally, you can include it in a route-specific pipeline: $app->post('/api/domain/transaction', [ ProblemDetailsMiddleware::class, BodyParamsMiddleware::class, DomainTransactionMiddleware::class, ]); Not Found handling When writing APIs you may also want 404 responses be in the accepted content-type. This package provides ProblemDetailsNotFoundHandler which will return a problem details Response with a 404 status if the request can accept either JSON or XML. To use this handler in Expressive add it into your pipeline immediate before the default NotFoundHandler : $app->pipe(\\Zend\\ProblemDetails\\ProblemDetailsNotFoundHandler::class); $app->pipe(NotFoundHandler::class);","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"","title":"Quick Start"},{"location":"quick-start/#installation","text":"To install this package in your application, use Composer : $ composer require zendframework/zend-problem-details","title":"Installation"},{"location":"quick-start/#usage","text":"This package provides three primary mechanisms for creating and returning Problem Details responses: ProblemDetailsResponseFactory for generating problem details responses on the fly from either PHP primitives or exceptions/throwables. ProblemDetailsExceptionInterface for creating exceptions with additional problem details that may be used when generating a response. ProblemDetailsMiddleware that acts as error/exception handler middleware, casting and throwing PHP errors as ErrorException instances, and all caught exceptions as problem details responses using the ProblemDetailsResponseFactory .","title":"Usage"},{"location":"response/","text":"Generating Problem Details Responses When writing middleware, you will often be able to detect error conditions within the middleware logic. When you do, you can immediately return a problem details response. ProblemDetailsResponseFactory This library provides a factory named Zend\\ProblemDetails\\ProblemDetailsResponseFactory . The factory has one required argument: a response factory capable of producing an mepty PSR-7 ResponseInterface . This may be an PHP callable. The class defines two static methods, createResponse() and createResponseFromThrowable() . Each accepts a PSR-7 ServerRequestInterface instance as its first argument, and then additional arguments in order to create the response itself: For createResponse() , the signature is: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; public function createResponse( ServerRequestInterface $request, int $status, string $detail, string $title = '', string $type = '', array $additional = [] ) : ResponseInterface { where: ServerRequestInterface $request is the current request. int $status indicates the HTTP status to return. string $detail is a short message describing the specifics of the problem. string $title = '' is a title for the general category of problem. This should be the same for all problems of the same type, and defaults to the HTTP reason phrase associated with the $status . string $type = '' is, generally, a URI to a human readable description of the general category of problem. array $additional is an associative array of additional data relevant to the specific problem being raised. This might be validation messages, transaction data, etc. The signature of createResponseFromThrowable() is: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; public function createResponseFromThrowable( ServerRequestInterface $request, Throwable $e ) : ResponseInterface { where: ServerRequestInterface $request is the current request. Throwable $e is an exception or throwable to use when generating problem details. By default, it will use the exception code for the HTTP status if it is in the 400-599 range, and the exception message for the detail. If the exception is a ProblemDetailsExceptionInterface , it will pull data via its exposed methods to populate the response; see the chapter on exceptions for more details. Normal usage of the factory will use a response and a stream from zend-diactoros for the response prototype and response body, respectively; additionally, responses will not include exception details (file, line number, backtrace, etc.), and JSON responses will use a set of flags for generating human-readable JSON. If these defaults work for your needs, you can instantiate the factory directly in your code in order to generate a response: // From scalar data: $response = (new ProblemDetailsResponseFactory())->createResponse( $request, 400, 'Unrecognized fields present in request' ); // From a throwable: $response = (new ProblemDetailsResponseFactory()) ->createResponseFromThrowable($request, $e); More often, you will want to customize behavior of the factory; for instance, you may want it to act differently in development than in production, or provide an alternate PSR-7 implementation. As such, the constructor has the following signature: use Psr\\Http\\Message\\ResponseInterface; public function __construct( callable $responseFactory, bool $isDebug = self::EXCLUDE_THROWABLE_DETAILS, int $jsonFlags = null, bool $exceptionDetailsInResponse = false, string $defaultDetailMessage = self::DEFAULT_DETAIL_MESSAGE ) { where: callable $responseFactory is a PHP callable that can produce a PSR-7 ResponseInterface . The factory will be invoked with no arguments. bool $isDebug is a flag indicating whether or not the factory should operate in debug mode; the default is not to. You may use the class constants INCLUDE_THROWABLE_DETAILS or EXCLUDE_THROWABLE_DETAILS if desired. int $jsonFlags is an integer bitmask of JSON encoding constants to use with json_encode() when generating JSON problem details. If you pass a null value, and the $isDebug flag is true, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE | JSON_PRESERVE_ZERO_FRACTION will be used; otherwise, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE | JSON_PRESERVE_ZERO_FRACTION will be used. bool $exceptionDetailsInResponse is a flag indicating whether or not to include exception details (in particular, the message) when creating the problem details response. By default, for non- ProblemDetailsExceptionInterface exceptions, we will not display the message unless this flag is toggled to true . string $defaultDetailMessage is a string value to use when the $exceptionDetailsInResponse flag is false , and a non- ProblemDetailsExceptionInterface exception is encountered. By default, this is set to the constant ProblemDetailsResponseFactory::DEFAULT_DETAIL_MESSAGE , which evaluates to 'An unknown error occurred.' ProblemDetailsResponseFactoryFactory This package also provides a factory for generating the ProblemDetailsResponseFactory for usage within dependency injection containers: Zend\\ProblemDetails\\ProblemDetailsResponseFactoryFactory . It does the following: Pulls the Psr\\Http\\Message\\ResponseInterface service to provide as the $responseFactory parameter. If a config service is present: If the service contains a debug key with a boolean value, that value is provided as the $isDebug parameter. If the service contains a problem-details key with an array value containing a json_flags key, and that value is an integer, that value is provided as the $jsonFlags parameter. If the service contains a problem-details key with an array value containing a default_types_map key, and that value is an array, that value is provided as the $defaultTypesMap parameter; see the default types documentation for details on defining this map. (Since 1.1.0.) If any of the above config values are not present, a null value will be passed, allowing the default value to be used. If you are using Expressive and have installed zend-component-installer in your application, the above factory will be wired already to the Zend\\ProblemDetails\\ProblemDetailsResponseFactory service via the provided Zend\\ProblemDetails\\ConfigProvider class. Response Factory You will need to provide a Psr\\Http\\Message\\ResponseInterface service that resolves to a PHP callable capable of returning an instance of that type. If you are using Expressive 3.0.0alpha8 or later, this service is provided via the zend-expressive package itself. Examples Returning a Problem Details response Let's say you have middleware that needs to return problem details: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\ProblemDetails\\ProblemDetailsResponseFactory; class ApiMiddleware implements MiddlewareInterface { private $problemDetailsFactory; public function __construct(ProblemDetailsResponseFactory $problemDetailsFactory) { $this->problemDetailsFactory = $problemDetailsFactory; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // discovered an error, so returning problem details: return $this->problemDetailsFactory->createResponse( $request, 403, 'You do not have valid credentials to access ' . $request->getUri()->getPath(), '', '', ['login' => '/login'] ); } } The above will return a JSON response if the Accept request header matches application/json or any application/*+json mediatype. Any other mediatype will generate an XML response. Using a Throwable to create the response Let's say you have middleware that invokes functionality from a service it composes, and that service could raise an exception or other Throwable . For this, you can use the createResponseFromThrowable() method instead. use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Throwable; use Zend\\ProblemDetails\\ProblemDetailsResponseFactory; class ApiMiddleware implements MiddlewareInterface { private $problemDetailsFactory; public function __construct(ProblemDetailsResponseFactory $problemDetailsFactory) { $this->problemDetailsFactory = $problemDetailsFactory; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { try { // some code that may raise an exception or throwable } catch (Throwable $e) { return $this->problemDetailsFactory ->createResponseFromThrowable($request, $e); } } } As with the previous example, the above will return a JSON response if the Accept request header matches application/json or any application/*+json mediatype. Any other mediatype will generate an XML response. By default, createResponseFromThrowable() will only use the exception message, and potentially the exception code (if it falls in the 400 or 500 range). If you want to include full exception details \u2014 line, file, backtrace, previous exceptions \u2014 you must pass a boolean true as the second argument to the constructor. In most cases, you should only do this in your development or testing environment; as such, you would need to provide a configuration flag for the ProblemDetailsResponseFactoryFactory to use. Creating Custom Response Types If you have common problem types you will use over and over again, you may not wish to provide the type , title , and/or status each time you create the problem details. For those, we suggest creating extensions to ProblemDetailsResponseFactory . To use the example from the introduction, we could have a RateLimitResponse generated as follows: use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\ProblemDetails\\ProblemDetailsResponseFactory; class RateLimitResponseFactory extends ProblemDetailsResponseFactory { const STATUS = 403; const TITLE = 'https://example.com/problems/rate-limit-exceeded'; const TYPE = 'You have exceeded the rate limit.'; public function create( ServerRequestInterface $request, int $tries, int $rateLimit, int $expires ) { return self::createResponse( $request, self::STATUS, sprintf('You have exceeded your %d requests per hour rate limit', $rateLimit), self::TITLE, self::TYPE, [ 'requests_this_hour' => $tries, 'rate_limit' => $rateLimit, 'rate_limit_reset' => date('c', $expires), ] ); } } You would then compose this alternate factory in your middleware, and invoke it as follows: $this->rateLimitResponseFactory->create( $request, $tries, $rateLimit, $expires );","title":"Generating Responses"},{"location":"response/#generating-problem-details-responses","text":"When writing middleware, you will often be able to detect error conditions within the middleware logic. When you do, you can immediately return a problem details response.","title":"Generating Problem Details Responses"},{"location":"response/#problemdetailsresponsefactory","text":"This library provides a factory named Zend\\ProblemDetails\\ProblemDetailsResponseFactory . The factory has one required argument: a response factory capable of producing an mepty PSR-7 ResponseInterface . This may be an PHP callable. The class defines two static methods, createResponse() and createResponseFromThrowable() . Each accepts a PSR-7 ServerRequestInterface instance as its first argument, and then additional arguments in order to create the response itself: For createResponse() , the signature is: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; public function createResponse( ServerRequestInterface $request, int $status, string $detail, string $title = '', string $type = '', array $additional = [] ) : ResponseInterface { where: ServerRequestInterface $request is the current request. int $status indicates the HTTP status to return. string $detail is a short message describing the specifics of the problem. string $title = '' is a title for the general category of problem. This should be the same for all problems of the same type, and defaults to the HTTP reason phrase associated with the $status . string $type = '' is, generally, a URI to a human readable description of the general category of problem. array $additional is an associative array of additional data relevant to the specific problem being raised. This might be validation messages, transaction data, etc. The signature of createResponseFromThrowable() is: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; public function createResponseFromThrowable( ServerRequestInterface $request, Throwable $e ) : ResponseInterface { where: ServerRequestInterface $request is the current request. Throwable $e is an exception or throwable to use when generating problem details. By default, it will use the exception code for the HTTP status if it is in the 400-599 range, and the exception message for the detail. If the exception is a ProblemDetailsExceptionInterface , it will pull data via its exposed methods to populate the response; see the chapter on exceptions for more details. Normal usage of the factory will use a response and a stream from zend-diactoros for the response prototype and response body, respectively; additionally, responses will not include exception details (file, line number, backtrace, etc.), and JSON responses will use a set of flags for generating human-readable JSON. If these defaults work for your needs, you can instantiate the factory directly in your code in order to generate a response: // From scalar data: $response = (new ProblemDetailsResponseFactory())->createResponse( $request, 400, 'Unrecognized fields present in request' ); // From a throwable: $response = (new ProblemDetailsResponseFactory()) ->createResponseFromThrowable($request, $e); More often, you will want to customize behavior of the factory; for instance, you may want it to act differently in development than in production, or provide an alternate PSR-7 implementation. As such, the constructor has the following signature: use Psr\\Http\\Message\\ResponseInterface; public function __construct( callable $responseFactory, bool $isDebug = self::EXCLUDE_THROWABLE_DETAILS, int $jsonFlags = null, bool $exceptionDetailsInResponse = false, string $defaultDetailMessage = self::DEFAULT_DETAIL_MESSAGE ) { where: callable $responseFactory is a PHP callable that can produce a PSR-7 ResponseInterface . The factory will be invoked with no arguments. bool $isDebug is a flag indicating whether or not the factory should operate in debug mode; the default is not to. You may use the class constants INCLUDE_THROWABLE_DETAILS or EXCLUDE_THROWABLE_DETAILS if desired. int $jsonFlags is an integer bitmask of JSON encoding constants to use with json_encode() when generating JSON problem details. If you pass a null value, and the $isDebug flag is true, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE | JSON_PRESERVE_ZERO_FRACTION will be used; otherwise, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE | JSON_PRESERVE_ZERO_FRACTION will be used. bool $exceptionDetailsInResponse is a flag indicating whether or not to include exception details (in particular, the message) when creating the problem details response. By default, for non- ProblemDetailsExceptionInterface exceptions, we will not display the message unless this flag is toggled to true . string $defaultDetailMessage is a string value to use when the $exceptionDetailsInResponse flag is false , and a non- ProblemDetailsExceptionInterface exception is encountered. By default, this is set to the constant ProblemDetailsResponseFactory::DEFAULT_DETAIL_MESSAGE , which evaluates to 'An unknown error occurred.'","title":"ProblemDetailsResponseFactory"},{"location":"response/#problemdetailsresponsefactoryfactory","text":"This package also provides a factory for generating the ProblemDetailsResponseFactory for usage within dependency injection containers: Zend\\ProblemDetails\\ProblemDetailsResponseFactoryFactory . It does the following: Pulls the Psr\\Http\\Message\\ResponseInterface service to provide as the $responseFactory parameter. If a config service is present: If the service contains a debug key with a boolean value, that value is provided as the $isDebug parameter. If the service contains a problem-details key with an array value containing a json_flags key, and that value is an integer, that value is provided as the $jsonFlags parameter. If the service contains a problem-details key with an array value containing a default_types_map key, and that value is an array, that value is provided as the $defaultTypesMap parameter; see the default types documentation for details on defining this map. (Since 1.1.0.) If any of the above config values are not present, a null value will be passed, allowing the default value to be used. If you are using Expressive and have installed zend-component-installer in your application, the above factory will be wired already to the Zend\\ProblemDetails\\ProblemDetailsResponseFactory service via the provided Zend\\ProblemDetails\\ConfigProvider class.","title":"ProblemDetailsResponseFactoryFactory"},{"location":"response/#examples","text":"","title":"Examples"}]}