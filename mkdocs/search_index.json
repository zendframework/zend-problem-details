{
    "docs": [
        {
            "location": "/",
            "text": "Problem Details for PSR-7 Applications\n\n\n\n\n\n\nThis library provides provides a factory for generating Problem Details\nresponses, error handling middleware for automatically generating Problem\nDetails responses from errors and exceptions, and custom exception types for\n\nPSR-7\n applications.\n\n\nInstallation\n\n\nRun the following to install this library:\n\n\n$ composer require zendframework/zend-problem-details\n\n\n\nDocumentation\n\n\nDocumentation is \nin the doc tree\n, and can be compiled using \nmkdocs\n:\n\n\n$ mkdocs build\n\n\n\nYou may also \nbrowse the documentation online\n.",
            "title": "Home"
        },
        {
            "location": "/#problem-details-for-psr-7-applications",
            "text": "This library provides provides a factory for generating Problem Details\nresponses, error handling middleware for automatically generating Problem\nDetails responses from errors and exceptions, and custom exception types for PSR-7  applications.",
            "title": "Problem Details for PSR-7 Applications"
        },
        {
            "location": "/#installation",
            "text": "Run the following to install this library:  $ composer require zendframework/zend-problem-details",
            "title": "Installation"
        },
        {
            "location": "/#documentation",
            "text": "Documentation is  in the doc tree , and can be compiled using  mkdocs :  $ mkdocs build  You may also  browse the documentation online .",
            "title": "Documentation"
        },
        {
            "location": "/intro/",
            "text": "Problem Details\n\n\nThis library addresses \nRFC 7807: Problem Details for HTTP APIs\n\nfor usage with \nPSR-7 HTTP Messages\n and\n\nhttp-interop/http-middleware\n.\n\n\nProblem Details for HTTP APIs\n\n\nWhen developing APIs, it is good practice to:\n\n\n\n\nUse HTTP status codes to help convey error status.\n\n\nProvide sufficient error detail to clients.\n\n\n\n\nUnfortunately, unless you are using a documented\n\nRPC\n format such as\nXML-RPC, JSON-RPC, or SOAP, \nhow\n to return error details is not dictated, and\nmany API developers end up creating their own formats. Most standardized\nRPC formats do not use the HTTP status code to convey an error, only the\npayload, and, in fact, most clients of such services will fail if a non-200\nstatus is returned.\n\n\nRFC 7807 provides a standard format for returning problem details from HTTP\nAPIs. In particular, it specifies the following:\n\n\n\n\nError responses MUST use standard HTTP status codes in the 400 or 500 range to\n  detail the general category of error.\n\n\nError responses will be of the \nContent-Type\n \napplication/problem\n,\n  appending a serialization format of either \njson\n or \nxml\n:\n  \napplication/problem+json\n, \napplication/problem+xml\n.\n\n\nError responses will have each of the following keys:\n\n\ndetail\n, a human-readable description of the specific error.\n\n\ntype\n, a unique URI for the general error type, generally pointing to\n    human-readable documentation of that given type.\n\n\ntitle\n, a short, human-readable title for the general error type; the title\n    should not change for given \ntype\ns.\n\n\nstatus\n, conveying the HTTP status code; this is so that all information\n    is in one place, but also to correct for changes in the status code due to\n    usage of proxy servers.\n\n\n\n\nOptionally, an \ninstance\n key may be present, with a unique URI for the specific\nerror; this will often point to an error log for that specific response.\n\n\nFinally, problem details are \nextensible\n. You may provide additional keys that\ngive the consumer more information about the error. As an example, in an API\nthat has rate limiting, you may want to indicate how many requests the user has\nmade, what the rate limit is, and when the limit resets:\n\n\n{\n    \"type\": \"https://example.com/problems/rate-limit-exceeded\",\n    \"title\": \"You have exceeded your API rate limit.\",\n    \"detail\": \"You have hit your rate limit of 5000 requests per hour.\",\n    \"requests_this_hour\": 5025,\n    \"rate_limit\": 5000,\n    \"rate_limit_reset\": \"2017-05-03T14:39-0500\"\n}\n\n\n\nCustom errors\n\n\nWhat if you have custom error types?\n\n\nRFC 7807 specifically allows you to define these with the following:\n\n\n\n\nA URI to documentation of the error \ntype\n.\n\n\nA human-readable \ntitle\n describing the error type.\n\n\nOne or more HTTP \nstatus\n codes associated with the error type.\n\n\n\n\nFor your custom errors, you use the above with a problem details response; if\nthe problem type requires additional information, you provide it within the\npayload, and document that information at the URI describing the type.\n\n\nThis approach allows usage of a single, general-purpose media type for returning\nproblem details for your HTTP API, while allowing full customization of what\ntypes of errors you report.\n\n\nProblemDetails\n\n\nThis library provides custom PSR-7 responses for JSON and XML representations of\n\napplication/problem\n. Additionally, it provides a factory that will introspect\nthe contents of a provided \nAccept\n header in order to determine which\nrepresentation to return, defaulting to the XML representation. This factory may\nthen be composed in middleware in order to create and return problem details\nresponses.\n\n\nAdditionally, the library provides middleware that acts as an error and\nexception handler and wrapping calls to a delegate, converting each into problem\ndetails responses.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#problem-details",
            "text": "This library addresses  RFC 7807: Problem Details for HTTP APIs \nfor usage with  PSR-7 HTTP Messages  and http-interop/http-middleware .",
            "title": "Problem Details"
        },
        {
            "location": "/intro/#problem-details-for-http-apis",
            "text": "When developing APIs, it is good practice to:   Use HTTP status codes to help convey error status.  Provide sufficient error detail to clients.   Unfortunately, unless you are using a documented RPC  format such as\nXML-RPC, JSON-RPC, or SOAP,  how  to return error details is not dictated, and\nmany API developers end up creating their own formats. Most standardized\nRPC formats do not use the HTTP status code to convey an error, only the\npayload, and, in fact, most clients of such services will fail if a non-200\nstatus is returned.  RFC 7807 provides a standard format for returning problem details from HTTP\nAPIs. In particular, it specifies the following:   Error responses MUST use standard HTTP status codes in the 400 or 500 range to\n  detail the general category of error.  Error responses will be of the  Content-Type   application/problem ,\n  appending a serialization format of either  json  or  xml :\n   application/problem+json ,  application/problem+xml .  Error responses will have each of the following keys:  detail , a human-readable description of the specific error.  type , a unique URI for the general error type, generally pointing to\n    human-readable documentation of that given type.  title , a short, human-readable title for the general error type; the title\n    should not change for given  type s.  status , conveying the HTTP status code; this is so that all information\n    is in one place, but also to correct for changes in the status code due to\n    usage of proxy servers.   Optionally, an  instance  key may be present, with a unique URI for the specific\nerror; this will often point to an error log for that specific response.  Finally, problem details are  extensible . You may provide additional keys that\ngive the consumer more information about the error. As an example, in an API\nthat has rate limiting, you may want to indicate how many requests the user has\nmade, what the rate limit is, and when the limit resets:  {\n    \"type\": \"https://example.com/problems/rate-limit-exceeded\",\n    \"title\": \"You have exceeded your API rate limit.\",\n    \"detail\": \"You have hit your rate limit of 5000 requests per hour.\",\n    \"requests_this_hour\": 5025,\n    \"rate_limit\": 5000,\n    \"rate_limit_reset\": \"2017-05-03T14:39-0500\"\n}",
            "title": "Problem Details for HTTP APIs"
        },
        {
            "location": "/intro/#custom-errors",
            "text": "What if you have custom error types?  RFC 7807 specifically allows you to define these with the following:   A URI to documentation of the error  type .  A human-readable  title  describing the error type.  One or more HTTP  status  codes associated with the error type.   For your custom errors, you use the above with a problem details response; if\nthe problem type requires additional information, you provide it within the\npayload, and document that information at the URI describing the type.  This approach allows usage of a single, general-purpose media type for returning\nproblem details for your HTTP API, while allowing full customization of what\ntypes of errors you report.",
            "title": "Custom errors"
        },
        {
            "location": "/intro/#problemdetails",
            "text": "This library provides custom PSR-7 responses for JSON and XML representations of application/problem . Additionally, it provides a factory that will introspect\nthe contents of a provided  Accept  header in order to determine which\nrepresentation to return, defaulting to the XML representation. This factory may\nthen be composed in middleware in order to create and return problem details\nresponses.  Additionally, the library provides middleware that acts as an error and\nexception handler and wrapping calls to a delegate, converting each into problem\ndetails responses.",
            "title": "ProblemDetails"
        },
        {
            "location": "/quick-start/",
            "text": "Quick Start\n\n\nInstallation\n\n\nTo install this package in your application, use\n\nComposer\n:\n\n\n$ composer require zendframework/zend-problem-details\n\n\n\nUsage\n\n\nThis package provides three primary mechanisms for creating and returning\nProblem Details responses:\n\n\n\n\nProblemDetailsResponseFactory\n for generating problem details responses on\n  the fly from either PHP primitives or exceptions/throwables.\n\n\nProblemDetailsExceptionInterface\n for creating exceptions with additional problem\n  details that may be used when generating a response.\n\n\nProblemDetailsMiddleware\n that acts as error/exception handler middleware,\n  casting and throwing PHP errors as \nErrorException\n instances, and all caught\n  exceptions as problem details responses using the\n  \nProblemDetailsResponseFactory\n.\n\n\n\n\nProblemDetailsResponseFactory\n\n\nIf you are using \nExpressive\n\nand have installed \nzend-component-installer\n\n(which is installed by default in v2.0 and above), you can write middleware that\ncomposes the \nZend\\ProblemDetails\\ProblemDetailsResponseFactory\n immediately, and\ninject that service in your middleware.\n\n\nAs an example, the following catches domain excpetions and uses them to create\nproblem details responses:\n\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\nuse Webimpress\\HttpMiddlewareCompatibility\\HandlerInterface as DelegateInterface;\nuse Webimpress\\HttpMiddlewareCompatibility\\MiddlewareInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\ProblemDetails\\ProblemDetailsResponseFactory;\n\nclass DomainTransactionMiddleware implements MiddlewareInterface\n{\n    private $domainService;\n\n    private $problemDetailsFactory;\n\n    public function __construct(\n        DomainService $service,\n        ProblemDetailsResponseFactory $problemDetailsFactory\n    ) {\n        $this->domainService = $service;\n        $this->problemDetailsFactory = $problemDetailsFactory;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        try {\n            $result = $this->domainService->transaction($request->getParsedBody());\n            return new JsonResponse($result);\n        } catch (DomainException $e) {\n            return $this->problemDetailsFactory->createResponseFromThrowable($request, $e);\n        }\n    }\n}\n\n\n\nThe factory for the above might look like:\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\ProblemDetails\\ProblemDetailsResponseFactory;\n\nclass DomainTransactionMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new DomainTransactionMiddleware(\n            $container->get(DomainService::class),\n            $container->get(ProblemDetailsResponseFactory::class)\n        );\n    }\n}\n\n\n\nAnother way to use the factory is to provide PHP primitives to the factory. As\nan example, validation failure is an expected condition, but should likely\nresult in problem details to the end user.\n\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\nuse Webimpress\\HttpMiddlewareCompatibility\\HandlerInterface as DelegateInterface;\nuse Webimpress\\HttpMiddlewareCompatibility\\MiddlewareInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\InputFilter\\InputFilterInterface;\nuse Zend\\ProblemDetails\\ProblemDetailsResponseFactory;\n\nclass DomainTransactionMiddleware implements MiddlewareInterface\n{\n    private $domainService;\n\n    private $inputFilter;\n\n    private $problemDetailsFactory;\n\n    public function __construct(\n        DomainService $service,\n        InputFilterInterface $inputFilter,\n        ProblemDetailsResponseFactory $problemDetailsFactory\n    ) {\n        $this->domainService = $service;\n        $this->inputFilter = $inputFilter;\n        $this->problemDetailsFactory = $problemDetailsFactory;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $this->inputFilter->setData($request->getParsedBody());\n        if (! $this->inputFilter->isValid()) {\n            return $this->problemDetailsFactory->createResponse(\n                $request,\n                422,\n                'Domain transaction request failed validation',\n                '',\n                '',\n                ['messages' => $this->inputFilter->getMessages()]\n            );\n        }\n\n        try {\n            $result =\n            $this->domainService->transaction($this->inputFilter->getValues());\n            return new JsonResponse($result);\n        } catch (DomainException $e) {\n            return $this->problemDetailsFactory->createResponseFromThrowable($request, $e);\n        }\n    }\n}\n\n\n\nThe above modifies the original example to add validation and, on failed\nvalidation, return a custom response that includes the validation failure\nmessages.\n\n\nCustom Exceptions\n\n\nIn the above examples, we have a \nDomainException\n that is used to create a\nProblem Details response. By default, in production mode, the factory will use\nthe exception message as the Problem Details description, and the exception code\nas the HTTP status if it falls in the 400 or 500 range (500 will be used\notherwise).\n\n\nYou can also create custom exceptions that provide details for the factory to\nconsume by implementing \nZend\\ProblemDetails\\Exception\\ProblemDetailsExceptionInterface\n,\nwhich defines the following:\n\n\nnamespace Zend\\ProblemDetails\\Exception;\n\nuse JsonSerializable;\n\ninterface ProblemDetailsExceptionInterface extends JsonSerializable\n{\n    public function getStatus() : int;\n    public function getType() : string;\n    public function getTitle() : string;\n    public function getDetail() : string;\n    public function getAdditionalData() : array;\n    public function toArray() : array;\n}\n\n\n\nWe also provide the trait \nCommonProblemDetailsExceptionTrait\n, which implements each\nof the above, the \njsonSerialize()\n method, and also defines the following\ninstance properties:\n\n\n/**\n * @var int\n */\nprivate $status;\n\n/**\n * @var string\n */\nprivate $detail;\n\n/**\n * @var string\n */\nprivate $title;\n\n/**\n * @var string\n */\nprivate $type;\n\n/**\n * @var array\n */\nprivate $additional = [];\n\n\n\nBy composing this trait, you can easily define custom exception types:\n\n\nnamespace Api;\n\nuse DomainException as PhpDomainException;\nuse Zend\\ProblemDetails\\Exception\\CommonProblemDetailsExceptionTrait;\nuse Zend\\ProblemDetails\\Exception\\ProblemDetailsExceptionInterface;\n\nclass DomainException extends PhpDomainException implements ProblemDetailsExceptionInterface\n{\n    use CommonProblemDetailsExceptionTrait;\n\n    public static function create(string $message, array $details) : DomainException\n    {\n        $e = new self($message)\n        $e->status = 417;\n        $e->detail = $message;\n        $e->type = 'https://example.com/api/doc/domain-exception';\n        $e->title = 'Domain transaction failed';\n        $e->additional['transaction'] = $details;\n        return $e;\n    }\n}\n\n\n\nThe data present in the generated exception will then be used by the\n\nProblemDetailsResponseFactory\n to generate full Problem Details.\n\n\nError handling\n\n\nWhen writing APIs, you may not want to handle every error or exception manually,\nor may not be aware of problems in your code that might lead to them. In such\ncases, having error handling middleware that can generate problem details can be\nhandy.\n\n\nThis package provides \nProblemDetailsMiddleware\n for that situation. It composes\na \nProblemDetailsResponseFactory\n, and does the following:\n\n\n\n\nIf the request can not accept either JSON or XML responses, it simply\n  passes handling to the delegate.\n\n\nOtherwise, it creates a PHP error handler that converts PHP errors to\n  \nErrorException\n instances, and then wraps processing of the delegate in a\n  try/catch block. If the delegate does not return a \nResponseInterface\n, a\n  \nProblemDetails\\Exception\\MissingResponseException\n is raised; otherwise, the\n  response is returned.\n\n\nAny throwable or exception caught is passed to the\n  \nProblemDetailsResponseFactory::createResponseFromThrowable()\n method, and the\n  response generated is returned.\n\n\n\n\nWhen using Expressive, the middleware service is already wired to a factory that\nensures the \nProblemDetailsResponseFactory\n is composed. As such, you can wire\nit into your workflow in several ways.\n\n\nFirst, you can have it intercept every request:\n\n\n$app->pipe(ProblemDetailsMiddleware::class);\n\n\n\nWith Expressive, you can also segregate this to a subpath:\n\n\n$app->pipe('/api', ProblemDetailsMiddleware::class);\n\n\n\nFinally, you can include it in a route-specific pipeline:\n\n\n$app->post('/api/domain/transaction', [\n    ProblemDetailsMiddleware::class,\n    BodyParamsMiddleware::class,\n    DomainTransactionMiddleware::class,\n]);\n\n\n\nNot Found handling\n\n\nWhen writing APIs you may also want 404 responses be in the accepted content-type.\nThis package provides \nProblemDetailsNotFoundHandler\n which will return a\nproblem details \nResponse\n with a \n404\n status if the request can accept either\nJSON or XML.\n\n\nTo use this handler in Expressive add it into your pipeline immediate before the \ndefault \nNotFoundHandler\n:\n\n\n$app->pipe(\\Zend\\ProblemDetails\\ProblemDetailsNotFoundHandler::class);\n$app->pipe(NotFoundHandler::class);",
            "title": "Quick Start"
        },
        {
            "location": "/quick-start/#quick-start",
            "text": "",
            "title": "Quick Start"
        },
        {
            "location": "/quick-start/#installation",
            "text": "To install this package in your application, use Composer :  $ composer require zendframework/zend-problem-details",
            "title": "Installation"
        },
        {
            "location": "/quick-start/#usage",
            "text": "This package provides three primary mechanisms for creating and returning\nProblem Details responses:   ProblemDetailsResponseFactory  for generating problem details responses on\n  the fly from either PHP primitives or exceptions/throwables.  ProblemDetailsExceptionInterface  for creating exceptions with additional problem\n  details that may be used when generating a response.  ProblemDetailsMiddleware  that acts as error/exception handler middleware,\n  casting and throwing PHP errors as  ErrorException  instances, and all caught\n  exceptions as problem details responses using the\n   ProblemDetailsResponseFactory .",
            "title": "Usage"
        },
        {
            "location": "/quick-start/#problemdetailsresponsefactory",
            "text": "If you are using  Expressive \nand have installed  zend-component-installer \n(which is installed by default in v2.0 and above), you can write middleware that\ncomposes the  Zend\\ProblemDetails\\ProblemDetailsResponseFactory  immediately, and\ninject that service in your middleware.  As an example, the following catches domain excpetions and uses them to create\nproblem details responses:  use Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\nuse Webimpress\\HttpMiddlewareCompatibility\\HandlerInterface as DelegateInterface;\nuse Webimpress\\HttpMiddlewareCompatibility\\MiddlewareInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\ProblemDetails\\ProblemDetailsResponseFactory;\n\nclass DomainTransactionMiddleware implements MiddlewareInterface\n{\n    private $domainService;\n\n    private $problemDetailsFactory;\n\n    public function __construct(\n        DomainService $service,\n        ProblemDetailsResponseFactory $problemDetailsFactory\n    ) {\n        $this->domainService = $service;\n        $this->problemDetailsFactory = $problemDetailsFactory;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        try {\n            $result = $this->domainService->transaction($request->getParsedBody());\n            return new JsonResponse($result);\n        } catch (DomainException $e) {\n            return $this->problemDetailsFactory->createResponseFromThrowable($request, $e);\n        }\n    }\n}  The factory for the above might look like:  use Psr\\Container\\ContainerInterface;\nuse Zend\\ProblemDetails\\ProblemDetailsResponseFactory;\n\nclass DomainTransactionMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new DomainTransactionMiddleware(\n            $container->get(DomainService::class),\n            $container->get(ProblemDetailsResponseFactory::class)\n        );\n    }\n}  Another way to use the factory is to provide PHP primitives to the factory. As\nan example, validation failure is an expected condition, but should likely\nresult in problem details to the end user.  use Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\nuse Webimpress\\HttpMiddlewareCompatibility\\HandlerInterface as DelegateInterface;\nuse Webimpress\\HttpMiddlewareCompatibility\\MiddlewareInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\InputFilter\\InputFilterInterface;\nuse Zend\\ProblemDetails\\ProblemDetailsResponseFactory;\n\nclass DomainTransactionMiddleware implements MiddlewareInterface\n{\n    private $domainService;\n\n    private $inputFilter;\n\n    private $problemDetailsFactory;\n\n    public function __construct(\n        DomainService $service,\n        InputFilterInterface $inputFilter,\n        ProblemDetailsResponseFactory $problemDetailsFactory\n    ) {\n        $this->domainService = $service;\n        $this->inputFilter = $inputFilter;\n        $this->problemDetailsFactory = $problemDetailsFactory;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $this->inputFilter->setData($request->getParsedBody());\n        if (! $this->inputFilter->isValid()) {\n            return $this->problemDetailsFactory->createResponse(\n                $request,\n                422,\n                'Domain transaction request failed validation',\n                '',\n                '',\n                ['messages' => $this->inputFilter->getMessages()]\n            );\n        }\n\n        try {\n            $result =\n            $this->domainService->transaction($this->inputFilter->getValues());\n            return new JsonResponse($result);\n        } catch (DomainException $e) {\n            return $this->problemDetailsFactory->createResponseFromThrowable($request, $e);\n        }\n    }\n}  The above modifies the original example to add validation and, on failed\nvalidation, return a custom response that includes the validation failure\nmessages.",
            "title": "ProblemDetailsResponseFactory"
        },
        {
            "location": "/quick-start/#custom-exceptions",
            "text": "In the above examples, we have a  DomainException  that is used to create a\nProblem Details response. By default, in production mode, the factory will use\nthe exception message as the Problem Details description, and the exception code\nas the HTTP status if it falls in the 400 or 500 range (500 will be used\notherwise).  You can also create custom exceptions that provide details for the factory to\nconsume by implementing  Zend\\ProblemDetails\\Exception\\ProblemDetailsExceptionInterface ,\nwhich defines the following:  namespace Zend\\ProblemDetails\\Exception;\n\nuse JsonSerializable;\n\ninterface ProblemDetailsExceptionInterface extends JsonSerializable\n{\n    public function getStatus() : int;\n    public function getType() : string;\n    public function getTitle() : string;\n    public function getDetail() : string;\n    public function getAdditionalData() : array;\n    public function toArray() : array;\n}  We also provide the trait  CommonProblemDetailsExceptionTrait , which implements each\nof the above, the  jsonSerialize()  method, and also defines the following\ninstance properties:  /**\n * @var int\n */\nprivate $status;\n\n/**\n * @var string\n */\nprivate $detail;\n\n/**\n * @var string\n */\nprivate $title;\n\n/**\n * @var string\n */\nprivate $type;\n\n/**\n * @var array\n */\nprivate $additional = [];  By composing this trait, you can easily define custom exception types:  namespace Api;\n\nuse DomainException as PhpDomainException;\nuse Zend\\ProblemDetails\\Exception\\CommonProblemDetailsExceptionTrait;\nuse Zend\\ProblemDetails\\Exception\\ProblemDetailsExceptionInterface;\n\nclass DomainException extends PhpDomainException implements ProblemDetailsExceptionInterface\n{\n    use CommonProblemDetailsExceptionTrait;\n\n    public static function create(string $message, array $details) : DomainException\n    {\n        $e = new self($message)\n        $e->status = 417;\n        $e->detail = $message;\n        $e->type = 'https://example.com/api/doc/domain-exception';\n        $e->title = 'Domain transaction failed';\n        $e->additional['transaction'] = $details;\n        return $e;\n    }\n}  The data present in the generated exception will then be used by the ProblemDetailsResponseFactory  to generate full Problem Details.",
            "title": "Custom Exceptions"
        },
        {
            "location": "/quick-start/#error-handling",
            "text": "When writing APIs, you may not want to handle every error or exception manually,\nor may not be aware of problems in your code that might lead to them. In such\ncases, having error handling middleware that can generate problem details can be\nhandy.  This package provides  ProblemDetailsMiddleware  for that situation. It composes\na  ProblemDetailsResponseFactory , and does the following:   If the request can not accept either JSON or XML responses, it simply\n  passes handling to the delegate.  Otherwise, it creates a PHP error handler that converts PHP errors to\n   ErrorException  instances, and then wraps processing of the delegate in a\n  try/catch block. If the delegate does not return a  ResponseInterface , a\n   ProblemDetails\\Exception\\MissingResponseException  is raised; otherwise, the\n  response is returned.  Any throwable or exception caught is passed to the\n   ProblemDetailsResponseFactory::createResponseFromThrowable()  method, and the\n  response generated is returned.   When using Expressive, the middleware service is already wired to a factory that\nensures the  ProblemDetailsResponseFactory  is composed. As such, you can wire\nit into your workflow in several ways.  First, you can have it intercept every request:  $app->pipe(ProblemDetailsMiddleware::class);  With Expressive, you can also segregate this to a subpath:  $app->pipe('/api', ProblemDetailsMiddleware::class);  Finally, you can include it in a route-specific pipeline:  $app->post('/api/domain/transaction', [\n    ProblemDetailsMiddleware::class,\n    BodyParamsMiddleware::class,\n    DomainTransactionMiddleware::class,\n]);",
            "title": "Error handling"
        },
        {
            "location": "/quick-start/#not-found-handling",
            "text": "When writing APIs you may also want 404 responses be in the accepted content-type.\nThis package provides  ProblemDetailsNotFoundHandler  which will return a\nproblem details  Response  with a  404  status if the request can accept either\nJSON or XML.  To use this handler in Expressive add it into your pipeline immediate before the \ndefault  NotFoundHandler :  $app->pipe(\\Zend\\ProblemDetails\\ProblemDetailsNotFoundHandler::class);\n$app->pipe(NotFoundHandler::class);",
            "title": "Not Found handling"
        },
        {
            "location": "/response/",
            "text": "Generating Problem Details Responses\n\n\nWhen writing middleware, you will often be able to detect error conditions\nwithin the middleware logic. When you do, you can immediately return a problem\ndetails response.\n\n\nProblemDetailsResponseFactory\n\n\nThis library provides a factory named \nZend\\ProblemDetails\\ProblemDetailsResponseFactory\n.\nIt defines two static methods, \ncreateResponse()\n and \ncreateResponseFromThrowable()\n.\nEach accepts the PSR-7 \nServerRequestInterface\n instance as its first argument,\nand then additional arguments in order to create the response itself:\n\n\nFor \ncreateResponse()\n, the signature is:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\npublic function createResponse(\n    ServerRequestInterface $request,\n    int $status,\n    string $detail,\n    string $title = '',\n    string $type = '',\n    array $additional = []\n) : ResponseInterface {\n\n\n\nwhere:\n\n\n\n\nServerRequestInterface $request\n is the current request.\n\n\nint $status\n indicates the HTTP status to return.\n\n\nstring $detail\n is a short message describing the specifics of the problem.\n\n\nstring $title = ''\n is a title for the general category of problem. This\n  should be the same for all problems of the same type, and defaults to the\n  HTTP reason phrase associated with the \n$status\n.\n\n\nstring $type = ''\n is, generally, a URI to a human readable description of\n  the general category of problem.\n\n\narray $additional\n is an associative array of additional data relevant to the\n  specific problem being raised. This might be validation messages,\n  transaction data, etc.\n\n\n\n\nThe signature of \ncreateResponseFromThrowable()\n is:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\npublic function createResponseFromThrowable(\n    ServerRequestInterface $request,\n    Throwable $e\n) : ResponseInterface {\n\n\n\nwhere:\n\n\n\n\nServerRequestInterface $request\n is the current request.\n\n\nThrowable $e\n is an exception or throwable to use when generating problem\n  details. By default, it will use the exception code for the HTTP status if it\n  is in the 400-599 range, and the exception message for the detail. If the\n  exception is a \nProblemDetailsExceptionInterface\n, it will pull data via its\n  exposed methods to populate the response; see the \nchapter on\n  exceptions\n for more details.\n\n\n\n\nNormal usage of the factory will use a response and a stream from\n\nzend-diactoros\n for the\nresponse prototype and response body, respectively; additionally, responses will\nnot include exception details (file, line number, backtrace, etc.), and JSON\nresponses will use a set of flags for generating human-readable JSON. If these\ndefaults work for your needs, you can instantiate the factory directly in your\ncode in order to generate a response:\n\n\n// From scalar data:\n$response = (new ProblemDetailsResponseFactory())->createResponse(\n    $request,\n    400,\n    'Unrecognized fields present in request'\n);\n\n// From a throwable:\n$response = (new ProblemDetailsResponseFactory())\n    ->createResponseFromThrowable($request, $e);\n\n\n\nMore often, you will want to customize behavior of the factory; for instance,\nyou may want it to act differently in development than in production, or provide\nan alternate PSR-7 implementation. As such, the constructor has the following\nsignature:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\n\npublic function __construct(\n    bool $isDebug = ProblemDetailsResponseFactory::EXCLUDE_THROWABLE_DETAILS,\n    int $jsonFlags = null,\n    ResponseInterface $response = null,\n    callable $bodyFactory = null\n) {\n\n\n\nwhere:\n\n\n\n\nbool $isDebug\n is a flag indicating whether or not the factory should operate\n  in debug mode; the default is not to. You may use the class constants\n  \nINCLUDE_THROWABLE_DETAILS\n or \nEXCLUDE_THROWABLE_DETAILS\n if desired.\n\n\nint $jsonFlags\n is an integer bitmask of \nJSON encoding\n  constants\n to use with\n  \njson_encode()\n when generating JSON problem details. If you pass a \nnull\n\n  value, \nJSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE |\n  JSON_PRESERVE_ZERO_FRACTION\n will be used.\n\n\nResponseInterface $response\n is a PSR-7 response instance to use as the base\n  for any generated response.\n\n\ncallable $bodyFactory\n is a PHP callable that will return a PSR-7\n  \nStreamInterface\n instance. Since some stream implementations are mutable (for\n  instance, those backed by a resource), a factory is necessary in order to\n  ensure a new instance is returned. If you provide such a factory, the stream\n  must be writable. The default will return a zend-diactoros \nStream\n instance\n  backed by a PHP temp stream in \nwb+\n mode.\n\n\n\n\nProblemDetailsResponseFactoryFactory\n\n\nThis package also provides a factory for generating the\n\nProblemDetailsResponseFactory\n for usage within dependency injection containers:\n\nZend\\ProblemDetails\\ProblemDetailsResponseFactoryFactory\n. It does the following:\n\n\n\n\nIf a \nconfig\n service is present:\n\n\nIf the service contains a \ndebug\n key with a boolean value, that value is\n  provided as the \n$isDebug\n parameter.\n\n\nIf the service contains a \nproblem-details\n key with an array value\n  containing a \njson_flags\n key, and that value is an integer, that value is\n  provided as the \n$jsonFlags\n parameter.\n\n\n\n\n\n\nIf a \nPsr\\Http\\Message\\ResponseInterface\n service is present, that service\n  will be provided as the \n$response\n parameter.\n\n\nIf a \nProblemDetails\\StreamFactory\n service is present, that service will be\n  provided as the \n$bodyFactory\n parameter.\n\n\n\n\nIf any of the above are not present, a \nnull\n value will be passed, allowing the\ndefault value to be used.\n\n\nIf you are using \nExpressive\n\nand have installed \nzend-component-installer\n\nin your application, the above factory will be wired already to the\n\nZend\\ProblemDetails\\ProblemDetailsResponseFactory\n service via the provided\n\nZend\\ProblemDetails\\ConfigProvider\n class.\n\n\nExamples\n\n\nReturning a Problem Details response\n\n\nLet's say you have middleware that you know will only be used in a production\ncontext, and need to return problem details:\n\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Webimpress\\HttpMiddlewareCompatibility\\HandlerInterface as DelegateInterface;\nuse Webimpress\\HttpMiddlewareCompatibility\\MiddlewareInterface;\nuse Zend\\ProblemDetails\\ProblemDetailsResponseFactory;\n\nclass ApiMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // discovered an error, so returning problem details:\n        return (new ProblemDetailsResponseFactory())->createResponse(\n            $request,\n            403,\n            'You do not have valid credentials to access ' . $request->getUri()->getPath(),\n            '',\n            '',\n            ['login' => '/login']\n        );\n    }\n}\n\n\n\nThe above will return a JSON response if the \nAccept\n request header matches\n\napplication/json\n or any \napplication/*+json\n mediatype. Any other mediatype\nwill generate an XML response.\n\n\nUsing a Throwable to create the response\n\n\nLet's say you have middleware that invokes functionality from a service it\ncomposes, and that service could raise an exception or other \nThrowable\n. For\nthis, you can use the \ncreateResponseFromThrowable()\n method instead.\n\n\nuse Interop\\Http\\Server\\MiddlewareInterface;\nuse Interop\\Http\\Server\\RequestHandlerInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\nuse Zend\\ProblemDetails\\ProblemDetailsResponseFactory;\n\nclass ApiMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler)\n    {\n        try {\n            // some code that may raise an exception or throwable\n        } catch (Throwable $e) {\n            return (new ProblemDetailsResponseFactory())\n                ->createResponseFromThrowable($request, $e);\n        }\n    }\n}\n\n\n\nAs with the previous example, the above will return a JSON response if the\n\nAccept\n request header matches \napplication/json\n or any \napplication/*+json\n\nmediatype. Any other mediatype will generate an XML response.\n\n\nBy default, \ncreateResponseFromThrowable()\n will only use the exception message, and\npotentially the exception code (if it falls in the 400 or 500 range). If you\nwant to include full exception details \u2014 line, file, backtrace, previous\nexceptions \u2014 you must pass a boolean \ntrue\n as the first argument to the\nconstructor. In most cases, you should only do this in your development or testing\nenvironment; as such, you would need to provide a flag to your middleware to use\nwhen invoking the \ncreateResponseFromThrowable()\n method, or, more correctly,\npass a configured \nProblemDetailsResponseFactory\n instance to your middleware's\nconstructor. As a more complete example:\n\n\nuse Interop\\Http\\Server\\MiddlewareInterface;\nuse Interop\\Http\\Server\\RequestHandlerInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\nuse Zend\\ProblemDetails\\ProblemDetailsResponseFactory;\n\nclass ApiMiddleware implements MiddlewareInterface\n{\n    private $problemDetailsFactory;\n\n    public function __construct(\n        /* other arguments*/\n        ProblemDetailsResponseFactory $problemDetailsFactory)\n    {\n        // ...\n        $this->problemDetailsFactory = $problemDetailsFactory;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler)\n    {\n        try {\n            // some code that may raise an exception or throwable\n        } catch (Throwable $e) {\n            return $this->problemDetailsFactory\n                ->createResponseFromThrowable($request, $e);\n        }\n    }\n}\n\n\n\nCreating Custom Response Types\n\n\nIf you have common problem types you will use over and over again, you may not\nwish to provide the \ntype\n, \ntitle\n, and/or \nstatus\n each time you create the\nproblem details. For those, we suggest creating extensions to\n\nProblemDetailsResponseFactory\n. To use the example from the introduction, we\ncould have a \nRateLimitResponse\n generated as follows:\n\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\ProblemDetails\\ProblemDetailsResponseFactory;\n\nclass RateLimitResponseFactory extends ProblemDetailsResponseFactory\n{\n    const STATUS = 403;\n    const TITLE = 'https://example.com/problems/rate-limit-exceeded';\n    const TYPE = 'You have exceeded the rate limit.';\n\n    public function create(\n        ServerRequestInterface $request,\n        int $tries,\n        int $rateLimit,\n        int $expires\n    ) {\n        return self::createResponse(\n            $request,\n            self::STATUS,\n            sprintf('You have exceeded your %d requests per hour rate limit', $rateLimit),\n            self::TITLE,\n            self::TYPE,\n            [\n                'requests_this_hour' => $tries,\n                'rate_limit' => $rateLimit,\n                'rate_limit_reset' => date('c', $expires),\n            ]\n        );\n    }\n}\n\n\n\nYou would then compose this alternate factory in your middleware, and invoke it\nas follows:\n\n\n$this->rateLimitResponseFactory->create(\n    $request,\n    $tries,\n    $rateLimit,\n    $expires\n);",
            "title": "Generating Responses"
        },
        {
            "location": "/response/#generating-problem-details-responses",
            "text": "When writing middleware, you will often be able to detect error conditions\nwithin the middleware logic. When you do, you can immediately return a problem\ndetails response.",
            "title": "Generating Problem Details Responses"
        },
        {
            "location": "/response/#problemdetailsresponsefactory",
            "text": "This library provides a factory named  Zend\\ProblemDetails\\ProblemDetailsResponseFactory .\nIt defines two static methods,  createResponse()  and  createResponseFromThrowable() .\nEach accepts the PSR-7  ServerRequestInterface  instance as its first argument,\nand then additional arguments in order to create the response itself:  For  createResponse() , the signature is:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\npublic function createResponse(\n    ServerRequestInterface $request,\n    int $status,\n    string $detail,\n    string $title = '',\n    string $type = '',\n    array $additional = []\n) : ResponseInterface {  where:   ServerRequestInterface $request  is the current request.  int $status  indicates the HTTP status to return.  string $detail  is a short message describing the specifics of the problem.  string $title = ''  is a title for the general category of problem. This\n  should be the same for all problems of the same type, and defaults to the\n  HTTP reason phrase associated with the  $status .  string $type = ''  is, generally, a URI to a human readable description of\n  the general category of problem.  array $additional  is an associative array of additional data relevant to the\n  specific problem being raised. This might be validation messages,\n  transaction data, etc.   The signature of  createResponseFromThrowable()  is:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\npublic function createResponseFromThrowable(\n    ServerRequestInterface $request,\n    Throwable $e\n) : ResponseInterface {  where:   ServerRequestInterface $request  is the current request.  Throwable $e  is an exception or throwable to use when generating problem\n  details. By default, it will use the exception code for the HTTP status if it\n  is in the 400-599 range, and the exception message for the detail. If the\n  exception is a  ProblemDetailsExceptionInterface , it will pull data via its\n  exposed methods to populate the response; see the  chapter on\n  exceptions  for more details.   Normal usage of the factory will use a response and a stream from zend-diactoros  for the\nresponse prototype and response body, respectively; additionally, responses will\nnot include exception details (file, line number, backtrace, etc.), and JSON\nresponses will use a set of flags for generating human-readable JSON. If these\ndefaults work for your needs, you can instantiate the factory directly in your\ncode in order to generate a response:  // From scalar data:\n$response = (new ProblemDetailsResponseFactory())->createResponse(\n    $request,\n    400,\n    'Unrecognized fields present in request'\n);\n\n// From a throwable:\n$response = (new ProblemDetailsResponseFactory())\n    ->createResponseFromThrowable($request, $e);  More often, you will want to customize behavior of the factory; for instance,\nyou may want it to act differently in development than in production, or provide\nan alternate PSR-7 implementation. As such, the constructor has the following\nsignature:  use Psr\\Http\\Message\\ResponseInterface;\n\npublic function __construct(\n    bool $isDebug = ProblemDetailsResponseFactory::EXCLUDE_THROWABLE_DETAILS,\n    int $jsonFlags = null,\n    ResponseInterface $response = null,\n    callable $bodyFactory = null\n) {  where:   bool $isDebug  is a flag indicating whether or not the factory should operate\n  in debug mode; the default is not to. You may use the class constants\n   INCLUDE_THROWABLE_DETAILS  or  EXCLUDE_THROWABLE_DETAILS  if desired.  int $jsonFlags  is an integer bitmask of  JSON encoding\n  constants  to use with\n   json_encode()  when generating JSON problem details. If you pass a  null \n  value,  JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE |\n  JSON_PRESERVE_ZERO_FRACTION  will be used.  ResponseInterface $response  is a PSR-7 response instance to use as the base\n  for any generated response.  callable $bodyFactory  is a PHP callable that will return a PSR-7\n   StreamInterface  instance. Since some stream implementations are mutable (for\n  instance, those backed by a resource), a factory is necessary in order to\n  ensure a new instance is returned. If you provide such a factory, the stream\n  must be writable. The default will return a zend-diactoros  Stream  instance\n  backed by a PHP temp stream in  wb+  mode.",
            "title": "ProblemDetailsResponseFactory"
        },
        {
            "location": "/response/#problemdetailsresponsefactoryfactory",
            "text": "This package also provides a factory for generating the ProblemDetailsResponseFactory  for usage within dependency injection containers: Zend\\ProblemDetails\\ProblemDetailsResponseFactoryFactory . It does the following:   If a  config  service is present:  If the service contains a  debug  key with a boolean value, that value is\n  provided as the  $isDebug  parameter.  If the service contains a  problem-details  key with an array value\n  containing a  json_flags  key, and that value is an integer, that value is\n  provided as the  $jsonFlags  parameter.    If a  Psr\\Http\\Message\\ResponseInterface  service is present, that service\n  will be provided as the  $response  parameter.  If a  ProblemDetails\\StreamFactory  service is present, that service will be\n  provided as the  $bodyFactory  parameter.   If any of the above are not present, a  null  value will be passed, allowing the\ndefault value to be used.  If you are using  Expressive \nand have installed  zend-component-installer \nin your application, the above factory will be wired already to the Zend\\ProblemDetails\\ProblemDetailsResponseFactory  service via the provided Zend\\ProblemDetails\\ConfigProvider  class.",
            "title": "ProblemDetailsResponseFactoryFactory"
        },
        {
            "location": "/response/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/response/#returning-a-problem-details-response",
            "text": "Let's say you have middleware that you know will only be used in a production\ncontext, and need to return problem details:  use Psr\\Http\\Message\\ServerRequestInterface;\nuse Webimpress\\HttpMiddlewareCompatibility\\HandlerInterface as DelegateInterface;\nuse Webimpress\\HttpMiddlewareCompatibility\\MiddlewareInterface;\nuse Zend\\ProblemDetails\\ProblemDetailsResponseFactory;\n\nclass ApiMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // discovered an error, so returning problem details:\n        return (new ProblemDetailsResponseFactory())->createResponse(\n            $request,\n            403,\n            'You do not have valid credentials to access ' . $request->getUri()->getPath(),\n            '',\n            '',\n            ['login' => '/login']\n        );\n    }\n}  The above will return a JSON response if the  Accept  request header matches application/json  or any  application/*+json  mediatype. Any other mediatype\nwill generate an XML response.",
            "title": "Returning a Problem Details response"
        },
        {
            "location": "/response/#using-a-throwable-to-create-the-response",
            "text": "Let's say you have middleware that invokes functionality from a service it\ncomposes, and that service could raise an exception or other  Throwable . For\nthis, you can use the  createResponseFromThrowable()  method instead.  use Interop\\Http\\Server\\MiddlewareInterface;\nuse Interop\\Http\\Server\\RequestHandlerInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\nuse Zend\\ProblemDetails\\ProblemDetailsResponseFactory;\n\nclass ApiMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler)\n    {\n        try {\n            // some code that may raise an exception or throwable\n        } catch (Throwable $e) {\n            return (new ProblemDetailsResponseFactory())\n                ->createResponseFromThrowable($request, $e);\n        }\n    }\n}  As with the previous example, the above will return a JSON response if the Accept  request header matches  application/json  or any  application/*+json \nmediatype. Any other mediatype will generate an XML response.  By default,  createResponseFromThrowable()  will only use the exception message, and\npotentially the exception code (if it falls in the 400 or 500 range). If you\nwant to include full exception details \u2014 line, file, backtrace, previous\nexceptions \u2014 you must pass a boolean  true  as the first argument to the\nconstructor. In most cases, you should only do this in your development or testing\nenvironment; as such, you would need to provide a flag to your middleware to use\nwhen invoking the  createResponseFromThrowable()  method, or, more correctly,\npass a configured  ProblemDetailsResponseFactory  instance to your middleware's\nconstructor. As a more complete example:  use Interop\\Http\\Server\\MiddlewareInterface;\nuse Interop\\Http\\Server\\RequestHandlerInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\nuse Zend\\ProblemDetails\\ProblemDetailsResponseFactory;\n\nclass ApiMiddleware implements MiddlewareInterface\n{\n    private $problemDetailsFactory;\n\n    public function __construct(\n        /* other arguments*/\n        ProblemDetailsResponseFactory $problemDetailsFactory)\n    {\n        // ...\n        $this->problemDetailsFactory = $problemDetailsFactory;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler)\n    {\n        try {\n            // some code that may raise an exception or throwable\n        } catch (Throwable $e) {\n            return $this->problemDetailsFactory\n                ->createResponseFromThrowable($request, $e);\n        }\n    }\n}",
            "title": "Using a Throwable to create the response"
        },
        {
            "location": "/response/#creating-custom-response-types",
            "text": "If you have common problem types you will use over and over again, you may not\nwish to provide the  type ,  title , and/or  status  each time you create the\nproblem details. For those, we suggest creating extensions to ProblemDetailsResponseFactory . To use the example from the introduction, we\ncould have a  RateLimitResponse  generated as follows:  use Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\ProblemDetails\\ProblemDetailsResponseFactory;\n\nclass RateLimitResponseFactory extends ProblemDetailsResponseFactory\n{\n    const STATUS = 403;\n    const TITLE = 'https://example.com/problems/rate-limit-exceeded';\n    const TYPE = 'You have exceeded the rate limit.';\n\n    public function create(\n        ServerRequestInterface $request,\n        int $tries,\n        int $rateLimit,\n        int $expires\n    ) {\n        return self::createResponse(\n            $request,\n            self::STATUS,\n            sprintf('You have exceeded your %d requests per hour rate limit', $rateLimit),\n            self::TITLE,\n            self::TYPE,\n            [\n                'requests_this_hour' => $tries,\n                'rate_limit' => $rateLimit,\n                'rate_limit_reset' => date('c', $expires),\n            ]\n        );\n    }\n}  You would then compose this alternate factory in your middleware, and invoke it\nas follows:  $this->rateLimitResponseFactory->create(\n    $request,\n    $tries,\n    $rateLimit,\n    $expires\n);",
            "title": "Creating Custom Response Types"
        },
        {
            "location": "/exception/",
            "text": "Problem Details Exceptions\n\n\nIf you are developing an API, it may be useful to raise exceptions from your\nbusiness domain that contain all the information necessary to report problem\ndetails.\n\n\nTo facilitate this, we provide an interface, \nProblemDetailsExceptionInterface\n:\n\n\nnamespace Zend\\ProblemDetails\\Exception;\n\nuse JsonSerializable;\n\ninterface ProblemDetailsExceptionInterface extends JsonSerializable\n{\n    public function getStatus() : int;\n\n    public function getType() : string;\n\n    public function getTitle() : string;\n\n    public function getDetail() : string;\n\n    public function getAdditionalData() : array;\n\n    public function toArray() : array;\n}\n\n\n\nYou may create exceptions that implement this interface. When such exceptions\nare passed to \nProblemDetailsResponseFactory::createResponseFromThrowable()\n,\nthese will pull the relevant details in order to create a Problem Details\nresponse.\n\n\nTo facilitate creating such exception types, we also ship the trait\n\nCommonProblemDetailsExceptionTrait\n. This trait defines the following properties:\n\n\n\n\n$status\n\n\n$detail\n\n\n$title\n\n\n$type\n\n\n$additional\n\n\n\n\nand implements each of the methods of the interface. This allows you as a\ndeveloper to create implementations with either constructors or named\nconstructors for generating exception instances.\n\n\nAs an example, if you wanted to create an exception type for providing\ntransaction problem details, you might do so as follows:\n\n\nuse DomainException;\nuse Zend\\ProblemDetails\\Exception\\CommonProblemDetailsExceptionTrait;\nuse Zend\\ProblemDetails\\Exception\\ProblemDetailsExceptionInterface;\n\nclass TransactionException extends DomainException implements ProblemDetailsExceptionInterface\n{\n    use CommonProblemDetailsExceptionTrait;\n\n    const STATUS = 403;\n    const TYPE = 'https://example.com/problems/insufficient-funds';\n    const TITLE = 'You have insufficient funds to complete the transaction.';\n\n    public static function create(int $needed, float $balance, string $account) : self\n    {\n        $e = new self(sprintf(\n            'Your transaction required %01.2f, but you only have %01.2f in your account',\n            $needed,\n            $balance\n        ));\n        $e->status = self::STATUS;\n        $e->type   = self::TYPE;\n        $e->title  = self::TITLE;\n        $e->additional = [\n            'account' => $account,\n            'balance' => $balance,\n        ];\n\n        return $e;\n    }\n}\n\n\n\nYou might then raise the exception as follows:\n\n\nthrow TransactionException::create($price, $balance, $accountUri);\n\n\n\nAnd it might result in the following:\n\n\n{\n    \"status\": 403,\n    \"type\": \"https://example.com/problems/insufficient-funds\",\n    \"title\": \"You have insufficient funds to complete the transaction.\",\n    \"detail\": \"Your transaction required 5.63, but you only have 1.37 in your account\",\n    \"account\": \"https://example.com/api/accounts/12345\",\n    \"balance\": 1.37\n}\n\n\n\nThe benefit to this approach is that you can easily provide domain-specific\nexceptions throughout your application that can, as a side-effect, be\nre-purposed immediately to provide problem details in your application.",
            "title": "Exceptions"
        },
        {
            "location": "/exception/#problem-details-exceptions",
            "text": "If you are developing an API, it may be useful to raise exceptions from your\nbusiness domain that contain all the information necessary to report problem\ndetails.  To facilitate this, we provide an interface,  ProblemDetailsExceptionInterface :  namespace Zend\\ProblemDetails\\Exception;\n\nuse JsonSerializable;\n\ninterface ProblemDetailsExceptionInterface extends JsonSerializable\n{\n    public function getStatus() : int;\n\n    public function getType() : string;\n\n    public function getTitle() : string;\n\n    public function getDetail() : string;\n\n    public function getAdditionalData() : array;\n\n    public function toArray() : array;\n}  You may create exceptions that implement this interface. When such exceptions\nare passed to  ProblemDetailsResponseFactory::createResponseFromThrowable() ,\nthese will pull the relevant details in order to create a Problem Details\nresponse.  To facilitate creating such exception types, we also ship the trait CommonProblemDetailsExceptionTrait . This trait defines the following properties:   $status  $detail  $title  $type  $additional   and implements each of the methods of the interface. This allows you as a\ndeveloper to create implementations with either constructors or named\nconstructors for generating exception instances.  As an example, if you wanted to create an exception type for providing\ntransaction problem details, you might do so as follows:  use DomainException;\nuse Zend\\ProblemDetails\\Exception\\CommonProblemDetailsExceptionTrait;\nuse Zend\\ProblemDetails\\Exception\\ProblemDetailsExceptionInterface;\n\nclass TransactionException extends DomainException implements ProblemDetailsExceptionInterface\n{\n    use CommonProblemDetailsExceptionTrait;\n\n    const STATUS = 403;\n    const TYPE = 'https://example.com/problems/insufficient-funds';\n    const TITLE = 'You have insufficient funds to complete the transaction.';\n\n    public static function create(int $needed, float $balance, string $account) : self\n    {\n        $e = new self(sprintf(\n            'Your transaction required %01.2f, but you only have %01.2f in your account',\n            $needed,\n            $balance\n        ));\n        $e->status = self::STATUS;\n        $e->type   = self::TYPE;\n        $e->title  = self::TITLE;\n        $e->additional = [\n            'account' => $account,\n            'balance' => $balance,\n        ];\n\n        return $e;\n    }\n}  You might then raise the exception as follows:  throw TransactionException::create($price, $balance, $accountUri);  And it might result in the following:  {\n    \"status\": 403,\n    \"type\": \"https://example.com/problems/insufficient-funds\",\n    \"title\": \"You have insufficient funds to complete the transaction.\",\n    \"detail\": \"Your transaction required 5.63, but you only have 1.37 in your account\",\n    \"account\": \"https://example.com/api/accounts/12345\",\n    \"balance\": 1.37\n}  The benefit to this approach is that you can easily provide domain-specific\nexceptions throughout your application that can, as a side-effect, be\nre-purposed immediately to provide problem details in your application.",
            "title": "Problem Details Exceptions"
        },
        {
            "location": "/middleware/",
            "text": "Problem Details Middleware\n\n\nWhile returning a problem details response from your own middleware is powerful\nand flexible, sometimes you may want a fail-safe way to return problem details\nfor any exception or PHP error that occurs without needing to catch and handle\nthem yourself.\n\n\nFor this purpose, this library provides \nProblemDetailsMiddleware\n.\n\n\nThis middleware does the following:\n\n\n\n\nComposes a \nProblemDetailsResponseFactory\n; if none is passed during\n  instantiation, one is created with no arguments, defaulting to usage of\n  zend-diactoros for response and response body generation, and defaulting to\n  production settings.\n\n\nDetermines if the request accepts JSON or XML; if neither is accepted, it\n  simply passes execution to the delegate.\n\n\nRegisters a PHP error handler using the current \nerror_reporting\n mask, and\n  throwing any errors handled as \nErrorException\n instances.\n\n\nWraps a call to the \n$delegate\n in a \ntry\n/\ncatch\n block; if nothing is\n  caught, and a response is returned, it returns the response immediately. If a\n  response is \nnot\n returned, it raises a\n  \nProblemDetails\\Exception\\MissingResponseException\n.\n\n\nFor all caught throwables, it passes the throwable to\n  \nProblemDetailsResponseFactory::createResponseFromThrowable()\n to generate a\n  Problem Details response.\n\n\n\n\nAs such, you can register this in middleware stacks in order to automate\ngeneration of problem details for exceptions and PHP errors.\n\n\nAs an example, using Expressive, you could compose it as an error handler within\nyour application pipeline, having it handle \nall\n errors and exceptions from\nyour application:\n\n\n$app->pipe(ProblemDetailsMiddleware::class);\n\n\n\nOr for a subpath of your application:\n\n\n$app->pipe('/api', ProblemDetailsMiddleware::class);\n\n\n\nAlternately, you could pipe it within a routed-middleware pipeline:\n\n\n$app->get('/api/books', [\n    ProblemDetailsMiddleware::class,\n    BooksList::class,\n], 'books');\n\n\n\nThis latter approach ensures that you are only providing problem details for\nspecific API endpoints, which can be useful when you have a mix of APIs and\ntraditional web content in your application.\n\n\nFactory\n\n\nThe \nProblemDetailsMiddleware\n ships with a corresponding PSR-11 compatible factory,\n\nProblemDetailsMiddlewareFactory\n. This factory looks for a service named\n\nZend\\ProblemDetails\\ProblemDetailsResponseFactory\n; if present, that value is used\nto instantiate the middleware.\n\n\nFor Expressive 2 users, this middleware should be registered automatically with\nyour application on install, assuming you have the zend-component-installer\nplugin in place (it's shipped by default with the Expressive skeleton).",
            "title": "Error Handling Middleware"
        },
        {
            "location": "/middleware/#problem-details-middleware",
            "text": "While returning a problem details response from your own middleware is powerful\nand flexible, sometimes you may want a fail-safe way to return problem details\nfor any exception or PHP error that occurs without needing to catch and handle\nthem yourself.  For this purpose, this library provides  ProblemDetailsMiddleware .  This middleware does the following:   Composes a  ProblemDetailsResponseFactory ; if none is passed during\n  instantiation, one is created with no arguments, defaulting to usage of\n  zend-diactoros for response and response body generation, and defaulting to\n  production settings.  Determines if the request accepts JSON or XML; if neither is accepted, it\n  simply passes execution to the delegate.  Registers a PHP error handler using the current  error_reporting  mask, and\n  throwing any errors handled as  ErrorException  instances.  Wraps a call to the  $delegate  in a  try / catch  block; if nothing is\n  caught, and a response is returned, it returns the response immediately. If a\n  response is  not  returned, it raises a\n   ProblemDetails\\Exception\\MissingResponseException .  For all caught throwables, it passes the throwable to\n   ProblemDetailsResponseFactory::createResponseFromThrowable()  to generate a\n  Problem Details response.   As such, you can register this in middleware stacks in order to automate\ngeneration of problem details for exceptions and PHP errors.  As an example, using Expressive, you could compose it as an error handler within\nyour application pipeline, having it handle  all  errors and exceptions from\nyour application:  $app->pipe(ProblemDetailsMiddleware::class);  Or for a subpath of your application:  $app->pipe('/api', ProblemDetailsMiddleware::class);  Alternately, you could pipe it within a routed-middleware pipeline:  $app->get('/api/books', [\n    ProblemDetailsMiddleware::class,\n    BooksList::class,\n], 'books');  This latter approach ensures that you are only providing problem details for\nspecific API endpoints, which can be useful when you have a mix of APIs and\ntraditional web content in your application.",
            "title": "Problem Details Middleware"
        },
        {
            "location": "/middleware/#factory",
            "text": "The  ProblemDetailsMiddleware  ships with a corresponding PSR-11 compatible factory, ProblemDetailsMiddlewareFactory . This factory looks for a service named Zend\\ProblemDetails\\ProblemDetailsResponseFactory ; if present, that value is used\nto instantiate the middleware.  For Expressive 2 users, this middleware should be registered automatically with\nyour application on install, assuming you have the zend-component-installer\nplugin in place (it's shipped by default with the Expressive skeleton).",
            "title": "Factory"
        },
        {
            "location": "/not-found-handler/",
            "text": "Not Found Handler\n\n\nThis library provides a Not Found handler so that returned 404 responses are in\nthe problem details format.\n\n\nThis handler will create a problem details \nResponse\n with a \n404\n status code and\na problem details body that will be rendered in either JSON or XML as required by\nthe request's \nAccept\n header.\n\n\nThis handler will only return a response if the request's accept header indicates\nthat it will accept either JSON or XML.\n\n\nTo use this handler in Expressive add it into your pipeline (usually \npipeline.php\n)\nimmediate before the default \nNotFoundHandler\n:\n\n\n$app->pipe(\\Zend\\ProblemDetails\\ProblemDetailsNotFoundHandler::class);\n$app->pipe(NotFoundHandler::class);",
            "title": "Not Found Handler"
        },
        {
            "location": "/not-found-handler/#not-found-handler",
            "text": "This library provides a Not Found handler so that returned 404 responses are in\nthe problem details format.  This handler will create a problem details  Response  with a  404  status code and\na problem details body that will be rendered in either JSON or XML as required by\nthe request's  Accept  header.  This handler will only return a response if the request's accept header indicates\nthat it will accept either JSON or XML.  To use this handler in Expressive add it into your pipeline (usually  pipeline.php )\nimmediate before the default  NotFoundHandler :  $app->pipe(\\Zend\\ProblemDetails\\ProblemDetailsNotFoundHandler::class);\n$app->pipe(NotFoundHandler::class);",
            "title": "Not Found Handler"
        }
    ]
}